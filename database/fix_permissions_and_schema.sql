-- 1. Ensure functions are secure and correct
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.users
    WHERE id = auth.uid()
    AND role = 'admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. RESET RLS on Users to ensure Admins can see everyone
DROP POLICY IF EXISTS "Admins can view all users" ON public.users;
DROP POLICY IF EXISTS "Admins can update users" ON public.users;
DROP POLICY IF EXISTS "Users can view own profile" ON public.users;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.users;

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Policy: Admins see everyone
CREATE POLICY "Admins see everyone" ON public.users
FOR SELECT TO authenticated
USING (
  public.is_admin() OR id = auth.uid()
);

-- Policy: Admins can update everyone
CREATE POLICY "Admins update everyone" ON public.users
FOR UPDATE TO authenticated
USING ( public.is_admin() );

-- Policy: Users update themselves (optional, for profile)
CREATE POLICY "Users update self" ON public.users
FOR UPDATE TO authenticated
USING ( id = auth.uid() );


-- 3. FIX VIP Subscriptions Policies
ALTER TABLE public.vip_subscriptions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins manage vip" ON public.vip_subscriptions
FOR ALL TO authenticated
USING ( public.is_admin() );

CREATE POLICY "Users view own vip" ON public.vip_subscriptions
FOR SELECT TO authenticated
USING ( user_id = auth.uid() );


-- 4. FIX Admin Messages Policies & Schema
CREATE TABLE IF NOT EXISTS public.admin_messages (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    sender_id uuid REFERENCES public.users(id) NOT NULL,
    receiver_id uuid REFERENCES public.users(id), -- Nullable for broadcast
    message text NOT NULL,
    created_at timestamptz DEFAULT now(),
    is_read boolean DEFAULT false
);

ALTER TABLE public.admin_messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins manage messages" ON public.admin_messages
FOR ALL TO authenticated
USING ( public.is_admin() );

CREATE POLICY "Users view own messages" ON public.admin_messages
FOR SELECT TO authenticated
USING ( receiver_id = auth.uid() OR receiver_id IS NULL );


-- 5. FIX Admin Logs Policies & Schema
CREATE TABLE IF NOT EXISTS public.admin_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    admin_id uuid REFERENCES public.users(id) NOT NULL,
    action TEXT NOT NULL,
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
); 
-- Note: schema had admin_id as bigint references users(id)? 
-- users.id is UUID in auth.users but BIGINT in public.users?
-- Wait, migrate_to_uuid.sql changed public.users.id to UUID.
-- So admin_logs.admin_id should be UUID.
-- If existing table has BIGINT, we might need to alter it.
-- Let's assume migrate_to_uuid was run. 

ALTER TABLE public.admin_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins manage logs" ON public.admin_logs
FOR ALL TO authenticated
USING ( public.is_admin() );


-- 6. Ensure Users table has email/phone columns (backfill if possible? No, can't backfill from here easily)
ALTER TABLE public.users 
ADD COLUMN IF NOT EXISTS email text,
ADD COLUMN IF NOT EXISTS phone text;

-- 7. Grant access to authenticated users generally (RLS handles restrictions)
GRANT ALL ON public.users TO authenticated;
GRANT ALL ON public.vip_subscriptions TO authenticated;
GRANT ALL ON public.admin_messages TO authenticated;
GRANT ALL ON public.admin_logs TO authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;
